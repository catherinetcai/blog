+++
date = 2017-03-13T05:03:20Z
draft = false
title = "WTF Algorithms - Add Two Numbers Represented as Linked Lists in Reverse Order"
aliases = ["/blog/2017/3/12/wtf-algorithms-add-two-numbers-represented-as-linked-lists-in-reverse-order"]
categories = ["avsnitt"]
+++


:&nbsp;You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order. You may assume the two numbers do not contain any leading zero, except the number 0 itself.&nbsp;
(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
(7 -&gt; 0 -&gt; 8)
Having never taken a formal CS class outside of a C++ 101 class, my first reaction to this problem was "WTF is a linked list?" To the Google for answers!
A linked list is a list of elements that contain a value and a reference to the next element in the list. There are two types of linked lists:
* Singly linked lists - Singly linked lists are as described above. They contain a value and a reference to the next element in the list.* Doubly linked lists - A doubly linked list just contains a reference to the previous node as well as the next node. Otherwise, it's identical to the singly linked list.Other key things about linked lists to keep in mind:
* Has the advantage over arrays in that it's dynamic in size.&nbsp;* You cannot directly access elements. You have to iterate over them to get a specific one.* The &nbsp;of a list is the first element/node in the list.For more on linked lists (including implementation of things like prepending and appending elements to a list), read[ this](https://www.cs.cmu.edu/~adamchik/15-121/lectures/Linked%20Lists/linked%20lists.html).
I haven't seen linked lists really used in Go. Since Go has slices, which can are essentially dynamically sized arrays, there's really no reason to use linked lists. However, there is an implementation of lists via [this list package](https://golang.org/pkg/container/list/#Init). It implements a doubly linked list and already contains some of the most useful functions for prepending/appending elements to a list, or inserting/removing specific elements. I'll be using this package instead of other implementations for solving this example.
Ok, let's jump back to the problem. We're essentially just going the most roundabout way to add 342 + 465. Our final answer is going to be a list that's the reverse of the sum. Our sum is 807, so we're going to expect our answer to look something like 7 -&gt; 0 -&gt; 8.
Since we already know what our answer should look like, we just need to figure out the way to get there.&nbsp;
Here's what we know:
* We're being given both numbers in reverse as a linked list* The only way we can really interact with linked lists is to iterate through them* The numbers will not contain any leading zeroesThe input that we've been given has the same length for both numbers, and even if they weren't the same length, summing things up aren't going to be horribly difficult, since each of the places are always going to match up since they're reversed. I know I'm not being horribly clear when I say this, but it would be a lot more difficult to sum up something like 342+1042 if we had two linked lists that represented them without reversal. That would mean that the ones, tens, hundreds, and thousands places wouldn't necessarily match up. Since our numbers are reversed, that will never be the case.&nbsp;
Since we're being fed lists and we can return lists, I realized that, for the most part, we can just get the sum of each element from both lists as they come and add them into our sumList. What do I mean?
The above is my naive implementation. I'm essentially going to be iterating through the list, so long as list1 and list2 have elements. Once I get the sum, I set sum to 0 so it's empty for the next loop's sum, and I set the currentElement for each list to be the next one so we can continue the loop.
However, we're going to run into a snag. When we get to the second element of both lists... 4 and 6, respectively, we're going to end up with a sum of 10. This is where the naive implementation breaks down. If we follow through with this, we're going to end up with a result of 7-&gt;10-&gt;7, which is not quite right.
Ok, so we essentially need a way to carry over any time our sum goes over 10 into the next list, while keeping the remainder of whatever the sum is subtracted by 10 in our current list. Whenever I run into something where I need to keep track of the remainder, I know that I'm going to have to do something with modulus.
This new implementation is a little more complicated. It keeps track of a carryover value (which will always be 1, because any single digit sum will never exceed having a 1 carry over - 9+9 = 18). Essentially, it's the same implementation as before, except we're going to be getting adding the modulus of the sum and 10, since we only want the modulus value and the carry over to be tracked in the next node. (Example, if we had a sum of 18, we'd only be storing 18%10, which is 8 in the list.) We're also checking to see if the sum at the end is greater than 10. If it is, we ensure that the carryover value is set to 1, so that it can be included in the sum on the next loop.
If you want to see my answer in depth, it's [here](https://github.com/catherinetcai/algorithms/tree/master/airbnb/add_two_numbers) (with a test case and all!) I realize that this isn't the most elegant solution, but it does work in a pinch. If you're going for gold though, here are some ways that it can improve:
* This won't sum up lists that don't match exactly in value. Implement something so that it can sum up things like 3-&gt;4-&gt;2 and 1 -&gt; 0 -&gt; 4 -&gt; 1.* The carryover being manually set as 1 and 0 is pretty gross. You can make this more elegant.
